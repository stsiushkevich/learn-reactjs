<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/basics/lifting-state-up" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<a name="pageStart"></a>
<lt:layout cssClass="page hello-world-example-page">
	<h1>2.11 Передача состояния вверх по иерархии</h1>

	<wg:p>Часто несколько компонентов должны отражать те же изменения данных. В таких случаях
		рекомендуется передавать состояние «наверх» по иерархии их ближайшему общему предку.
		Давайте посмотрим как это работает на деле.</wg:p>

	<wg:p>В этом разделе мы создадим полицейский радар скорости, которая
		сообщает – превышена ли текущая скорость.</wg:p>

	<wg:p>Начнем с компонента, под названием <code>SpeedDetector</code>. Он принимает текущую скорость <code>speed</code>
		и максимальную скорость <code>maxSpeed</code> в км/ч как свойства и выводит сообщение, превышена ли скорость:</wg:p>

	<ce:code-example-1/>

	<wg:p>Далее мы создадим компонент – радар скорости, под названием <code>SpeedRadar</code>.
		Он отрисовывает <code>&lt;input&gt;</code>, который позволяет нам вводить скорость и хранить ее
		значение в <code>this.state.speed</code>.</wg:p>

	<ce:code-example-2 codePenUrl="https://codepen.io/stzidane/pen/GmPmmq?editors=0010"/>

	<br/>
	<h2>2.11.1	Передача состояния вверх по иерархии</h2>

	<wg:p>На данный момент оба компонента <code>SpeedSetter</code> независимо
		хранят свои значения в локальном состоянии:</wg:p>

	<ce:code-example-3/>

	<wg:p>Тем не менее, нам нужно два этих установщика синхронизировать между собой. Когда
		обновится установщик «<b>км/ч</b>» - установщик «<b>миль/ч</b>» отобразит
		конвертированное значение, и наоборот.</wg:p>

	<wg:p>В React, общее использование состояние достигается путем передачи его
		вверх ближайшему общему предку компонентов, которые в нём нуждаются.
		Это называется «<b>подъем состояния</b>» в оригинале «<b>lifting state up</b>».
		Мы удалим локальное состояние из <code>SpeedSetter</code> и перенесем его в <code>SpeedRadar</code>.</wg:p>

	<wg:p>Если <code>SpeedRadar</code> владеет совместно используемым состоянием, то он становится
		«<b>источником истины</b>» для текущей скорости в обоих установщиках. Он будет поручать
		установщикам использовать значения, которые согласуются друг с другом. Как только
		свойства props обоих компонентов <code>SpeedSetter</code> придут с родительского компонента
		<code>SpeedRadar</code>, оба установщика скорости всегда будут синхронизированы.</wg:p>

	<wg:p>Давайте посмотрим, как это работает пошагово.</wg:p>

	<wg:p>Для начала, мы заменим <code>this.state.speed</code> на <code>this.props.speed</code>
		в компонентах <code>SpeedSetter</code>. Теперь, давайте представим, что
		<code>this.props.speed</code> уже существует, хотя нам будет необходимо
		передать его из компонента <code>SpeedRadar</code> в будущем:</wg:p>

	<ce:code-example-4/>

	<wg:p>Мы знаем, что свойства являются только для чтения. Когда скорость <code>speed</code> была в
		локальном состоянии, компонент <code>SpeedSetter</code> мог просто вызвать <code>this.setState()</code>,
		чтобы ее изменить. Однако так как сейчас скорость приходит с родительского компонента
		как свойство в <code>prop</code>, <code>SpeedSetter</code> теперь не имеет над ней контроля.</wg:p>

	<wg:p>Как правило, в React это обычно решается путем создания «контролируемого» комопнента.
		Так же как DOM элемент <code>&lt;input&gt;</code> принимает и <code>value</code>, и <code>onChange</code> свойства,
		так и компонент <code>SpeedSetter</code> может принимать <code>speed</code> и <code>onSpeedChange</code>
		свойства со своего родительского компонента <code>SpeedRadar</code>.</wg:p>

	<wg:p>Сейчас, когда <code>SpeedSetter</code> захочет обновить свою скорость <code>speed</code>,
		он вызовет <code>this.props.onSpeedChange</code>:</wg:p>

	<ce:code-example-5/>

	<wg:p>Обратите внимание, что нет никакого особого смысла в названиях свойств
		<code>speed</code> и <code>onSpeedChange</code> в пользовательских компонентах. Мы могли бы назвать их
		как угодно, например <code>value</code> и <code>onChange</code>, что не противоречит общему соглашению.</wg:p>

	<wg:p>Свойства <code>onSpeedChange</code> и <code>speed</code> будут предоставлены совместно родительским
		компонентом <code>SpeedRadar</code>. Он обработает изменение с помощью модификации своего локального состояния,
		что вызовет перерисовку обоих установщиков <code>SpeedSetter</code> с новыми значениями скорости.
		Мы посмотрим на новую реализацию <code>SpeedRadar</code> очень скоро.</wg:p>

	<wg:p>Перед погружением в анализ изменений в компоненте <code>SpeedRadar</code>, давайте прорезюмируем наши изменения в
		компоненте <code>SpeedSetter</code>. Мы удалили из него локальное состояние, и вместо чтения значения <code>this.state.speed</code>,
		сейчас мы читаем значение <code>this.props.speed</code>. Вместо вызова <code>this.setState()</code>, когда мы хотим сделать
		изменение скорости, мы сейчас вызываем <code>this.props.onSpeedChange()</code>, который будет
		предоставляться компонентом <code>SpeedRadar</code>:</wg:p>

	<ce:code-example-6/>

	<wg:p>Теперь давайте перейдем к компоненту <code>SpeedRadar</code>.</wg:p>

	<wg:p>Мы будем хранить текущую введенную скорость <code>speed</code> и единицу
		измерения <code>unit</code> в его локальном состоянии.
		Это состояние мы «<b>подняли</b>» с установщиков скорости. Теперь оно будет
		служить «<b>единственным источником истины</b>» для них обоих. Это минимальное представление
		всех данных, которые нам необходимо знать, чтобы отрисовать оба установщика.</wg:p>

	<wg:p>К примеру, если мы вводим <code>40</code> в установщик «Км/ч», состояние компонента <code>SpeedRadar</code> будет:</wg:p>

	<ce:code-example-7/>

	<wg:p>Если далее мы введем в поле «Миль/ч» значение <code>80</code>, состояние <code>SpeedRadar</code> будет:</wg:p>

	<ce:code-example-8/>

	<wg:p>Мы могли бы хранить значения обоих установщиков, но это оказывается необязательным.
		Достаточно хранить значение недавнего установщика и единицу измерения, которую он представляет.
		Далее мы можем определить значение другого установщика, основываясь на текущей
		скорости <code>speed</code> и его единице измерения <code>unit</code>.</wg:p>

	<wg:p>Состояния установщиков синхронизированы, так как их значения вычислены из того же самого состояния:</wg:p>

	<ce:code-example-9 codePenUrl="https://codepen.io/stzidane/pen/dWEZro?editors=0010"/>

	<wg:p>Сейчас не имеет значения в какое поле вы вводите значение: <code>this.state.speed</code> и <code>this.state.unit</code> в
		компоненте <code>SpeedRadar</code> будут обновлены. Один из элементов <code>input</code> получает значение как есть, поэтому
		любое введенное в него значение пользователя сохраняется, а значение другого <code>input</code> всегда будет
		вычислено на основании первоначального.</wg:p>

	<wg:p>Давайте прорезюмируем, что происходит, когда мы редактируем <code>input:</code></wg:p>

	<wg:p>
		<ul>
			<li>React вызывает функцию, указанную в атрибуте <code>nChange</code> DOM элемента <code>&lt;input&gt;</code>.
				В нашем случае, это метод <code>onChange</code> в компоненте <code>SpeedSetter</code>.</li>

			<li>Метод <code>onChange</code> в компоненте <code>SpeedSetter</code> вызывает
				<code>this.props.onSpeedChange()</code> с новым требуемым значением.
				Эти свойства, включая <code>onSpeedChange</code>, были предоставлены его
				родительским компонентом - <code>SpeedRadar</code>.</li>

			<li>Когда <code>SpeedRadar</code> отрисовывался в предыдущий раз, он указал, что <code>onSpeedChange</code>
				компонента <code>SpeedSetter</code> с единицами «Км/ч» является методом <code>onSpeedInKphChange</code>
				компонента <code>SpeedRadar</code>, а <code>onSpeedChange</code> компонента <code>SpeedSetter</code> с единицами «Миль/ч»
				соответственно является методом <code>onSpeedInMphChange</code> компонента <code>SpeedRadar</code>.
				Таким образом каждый из этих двух методов <code>SpeedRadar</code> будет вызван, в зависимости
				от того, какой <code>&lt;input&gt;</code> мы отредактировали.</li>

			<li>Внутри этих методов, компонент <code>SpeedRadar</code> запрашивает React перерисовать себя с
				помощью вызова <code>this.setState()</code> с новым введенным значением скорости и единицей измерения
				скорости элемента <code>&lt;input&gt;</code>, который мы только что отредактировали.</li>

			<li>React вызывает метод <code>render()</code> компонента <code>SpeedRadar</code>, чтобы понять как должен выглядеть UI.
				Значения обоих элементов <code>&lt;input&gt;</code> пересчитываются, на основании текущего значения скорости и
				активной единицы измерения. Здесь же выполняется и конвертация скорости.</li>

			<li>React вызывает методы <code>render()</code> компонентов <code>SpeedSetter</code> индивидуально с их новыми свойствами,
				указанными компонентом <code>SpeedRadar</code>. Так он узнает, как должен выглядеть их UI.</li>

			<li>React DOM обновляет DOM чтобы привести в соответствие требуемые введенные значения. Элемент
				<code>&lt;input&gt;</code>, который мы только что отредактировали, принимает его текущее значение, а второй
				<code>&lt;input&gt;</code> обновляется к  значению скорости после конвертации.</li>
		</ul>
	</wg:p>

	<wg:p>Каждое обновление проходит через эти же самые шаги, так что элементы
		<code>&lt;input&gt;</code> всегда остаются синхронизированными.</wg:p>

	<br/>
	<h2>2.11.2	Извлеченные уроки</h2>

	<wg:p>Должен существовать лишь один «<b>источник истины</b>» для любых данных, которые изменяются в
		приложении React. Обычно состояние сперва добавляется в компонент, который требует его для
		отрисовки. Затем, если другие компоненты тоже требуют его, вы можете «поднять» состояние к
		их ближайшему общему предку. Вместо попыток синхронизировать состояние между различными
		компонентами, вам следует полагаться на нисходящий поток данных.</wg:p>

	<wg:p>Поднятие состояния влечет за собой написание более «шаблонного» кода, чем подходы,
		использующие с двойную привязку, но, как вознаграждение, на поиск и изоляцию багов уходит
		меньше работы. Так только какое-либо состояние «начало жить» в каком-нибудь компоненте и
		этот компонент единственный, кто может его изменять, объем пространства для багов значительно
		сокращается. В дополнение, вы можете реализовать любую кастомную логику, чтобы отклонить или
		преобразовать пользовательский ввод.</wg:p>

	<wg:p>Если что-либо может быть извлечено и из состояния, и из свойств, возможно, это не должно
		находиться в состоянии. К примеру, вместо хранения в состоянии <code>kphValue</code> и <code>mphValue</code>, мы храним
		только последнее отредактированное значение скорости <code>speed</code> и ее единицу измерения unit.
		Значение другого элемента <code>input</code> всегда может быть вычислено из них в методе <code>render()</code>. Это позволяет
		нам убрать или применить округление к другому полю без потери какой-либо точности данных,
		введенных пользователем.</wg:p>

	<wg:p>Когда вы видите что-то неправильное в UI, вы можете использовать
		<wg:link href="https://github.com/facebook/react-devtools">React Developer Tools</wg:link> , чтобы
		проинспектировать свойства и подняться по дереву вверх до тех пор, пока не найдете компонент,
		ответственный за обновление состояния. Это позволит вам отследить баги вплоть до их источника.</wg:p>
</lt:layout>

<c:url var="prevPageUrl" value="forms"/>
<c:url var="nextPageUrl" value="composition-vs-inheritance"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
									 pageStartAncor="pageStart"
									 nextPageUrl="${nextPageUrl}"/>