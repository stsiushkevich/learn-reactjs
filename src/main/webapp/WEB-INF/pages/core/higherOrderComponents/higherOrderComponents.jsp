<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/higher-order-components" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="granularDomUpdatesUrl" value="/resources/imges/pages/basics/render-elements/granular-dom-updates.gif"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page hello-world-example-page">
  <h1>3.13	Компоненты более высокого порядка (старшие компоненты)</h1>

  <wg:p>Компонент более высокого порядка (КБВП) (в докментации <b>Higher-Order Components</b> – сокращенно <b>HOC</b>),
    или старшие компоненты представляет собой усовершенствованный подход в React для
    повторного использования логики компонентов. Старшие компоненты не являются частью
    React API, как таковой. Они представляют собой паттерн, который возникает из композиционной природы React.</wg:p>

  <wg:p><b>Компонент более высокого порядка, или старший компонент - это функция,
    которая принимает компонент и возвращает новый компонент.</b></wg:p>

  <ce:code-example-1/>

  <wg:p>В то время как компонент преобразует <code>props</code>. в UI, старший компонент преобразует
    компонент в другой компонент.</wg:p>

  <wg:p>КБВП являются общими для сторонних библиотек React, таких как Redux
    <code>connect</code> и <code>createContainer</code> Relay.</wg:p>

  <wg:p>В этой главе мы обсудим, почему старшие компоненты полезны и как писать свои собственные.</wg:p>

  <br/>
  <h2>3.13.1	Использование старших компонентов для сквозной функциональности</h2>

  <lt:layout>
    <b>Внимание!</b> Ранее рекомендовалось использовать миксины для сквозной функциональности.
    С тех пор разработчики поняли, что миксины создают больше проблем, чем они того стоят.
    Узнайте больше о том, почему они отошли от миксинов и как вы можете перевести свои уже
    существующиме компоненты.
  </lt:layout>

  <wg:p>Компоненты являются основной единицей повторного использования кода в React. Тем не менее,
    вы обнаружите, что некоторые паттерны не подходят для традиционных компонентов.</wg:p>

  <wg:p>Например, предположим, что у вас есть компонент <code>NotifacationList</code>, который
    подписывается на внешний источник данных для отображения списка уведомлений:</wg:p>

  <ce:code-example-2/>

  <wg:p>Позже вы пишете компонент для подписки на одно уведомление, который следует аналогичному шаблону:</wg:p>

  <ce:code-example-3/>

  <wg:p><code>NotificationList</code> и <code>NotificationDetails</code> не идентичны - они используют разные методы
    <code>NotificationDataStore</code> и выводят разные результаты. Но большая часть их реализации одинакова:</wg:p>

  <wg:p>
    <ul>
      <li>Сразу после монтирования добавляется слушавтель изменений в <code>NotificationDataStore</code>.</li>
      <li>Внутри слушателя <code>setState</code> вызывается каждый раз, когда изменяется источник данных.</li>
      <li>При демонтаже слушатель изменений удаляется.</li>
    </ul>
  </wg:p>

  <wg:p>Вы можете себе представить, что в большом приложении этот шаблон: подписка
    на <code>NotificationDataStore</code> и вызов <code>setState</code> будет повторяться снова и снова. Следовательно
    нам нужна абстракция, которая позволит определить эту логику в одном месте и использовать
    ее всеми компонентами. Именно здесь вытеляются компоненты более высокого порядка.</wg:p>

  <wg:p>Мы можем написать функцию, которая создает компоненты, такие как <code>NotificationList</code>
    и <code>NotificationDetails</code>, которые подписываются на <code>NotificationDataStore</code>. Функция будет
    принимать в качестве одного из своих аргументов дочерний компонент, который получает
    данные подписки в как свойство. Назовем эту функцию <code>addSubscription</code>:</wg:p>

  <ce:code-example-4/>

  <wg:p>Первый параметр - это оборачиваемый компонент. Второй параметр извлекает данные,
    которые нас интересуют, используя <code>NotificationDataStore</code> и текущие свойства.</wg:p>

  <wg:p>Когда <code>NotificationListWithSubscription</code> и <code>NotificationDetailsWithSubscription</code>
    отрисовываются, <code>NotificationList</code> и <code>NotificationDetails</code> получат свойство <code>data</code>, с
    самыми последними данными, полученными из <code>NotificationDataStore</code>:</wg:p>

  <ce:code-example-5/>

  <wg:p>Обратите внимание, что старший компонент не изменяет оригинальный компонент и не использует
    наследование для копирования его поведения. Вместо этого, старший компонент применяет композицию к
    исходному компоненту, обернув его в компонент-контейнер. Старший компонент - чистая функция с
    нулевыми побочными эффектами.</wg:p>

  <wg:p>Вот и все! Обернутый компонент получает все свойства контейнера вместе с новым
    свойством <code>prop</code>, которые он использует для своей отрисовки. Старший компонент не имеет
    отношения к тому, как используются данные, а упакованный компонент не имеет отношения к
    тому, откуда пришли данные.</wg:p>

  <wg:p>Так как <code>addSubscription</code> является обычной функцией, вы можете добавить столько
    аргументов, сколько захотите. Например, вы можете захотеть указать имя свойства
    <code>data</code> конфигурируемым, чтобы дополнительно изолировать старший компонент от упакованного
    компонента. Или же, вы можете принять аргумент, который конфигурирует <code>shouldComponentUpdate</code>,
    либо, который настраивает источник данных. Все это является возможным, поскольку
    старший компонент имеет полный контроль над тем, как он определен.</wg:p>

  <wg:p>Как и компоненты, взаимодействие между <code>addSubscription</code> и упакованным компонентом
    полностью основано на свойствах <code>props</code>. Это упрощает замену одного старшего компонента
    на другой, если они предоставляют те же свойства <code>props</code> для упакованного компонента.
    Это может оказаться полезным, если вы, например, поменяете библиотеки для извлечения данных.</wg:p>

  <br/>
  <h2>3.13.2	Не изменяйте оригинальный компонент. Используйте композицию</h2>

  <wg:p>Сопротивляйтесь соблазну модифицировать прототип компонента
    (или каким-то иным образом его изменить) внутри старшего компонента.</wg:p>

  <ce:code-example-6/>

  <wg:p>Здесь есть несколько проблем. Во-первых, входной компонент нельзя повторно использовать
    отдельно от модифицированного компонента. Более того, если вы примените еще один старший
    компонент к <code>ComponentWithDebug</code>, который также будет изменять например
    <code>componentDidMount</code>, то функция первого старшего компонента будет переопределена!
    Кроме того, такой старший компонент не будет работать с функциональными компонентами,
    которые не имеют методов жизненного цикла.</wg:p>

  <wg:p>Изменяющий старший компонент - это плохая абстракция, так как тот, кто его использует,
    должен знать его детали реализации, чтобы избежать конфликтов с другими старшими объектами.</wg:p>

  <wg:p>Вместо изменения оригинального компонента старшим компонентом вы должны использовать
    композицию, обертывая входной компонент в компонент-контейнер:</wg:p>

  <ce:code-example-7/>

  <wg:p>Такой старший компонент имеет те же функциональные возможности, что и изменяющая версия,
    но при этом избегает потенциальных конфликтов. Он одинаково хорошо работает с компонентами-классами
    и функциональными компонентами. И поскольку это чистая функция, она может быть скомбинирована с
    другими старшими компонентами или даже с самим собой.</wg:p>

  <wg:p>Возможно, вы заметили сходство между старшим компонентом и паттерном, называемым
    <b>компонент-контейнер</b>. Компоненты-контейнеры являются частью стратегии разделения
    ответственности между проблемами высокого и низкого уровней. Контейнеры управляют
    такими вещами, как <b>подписки</b> и <b>состояние</b>, и передают <b>свойства компонентам</b>, которые
    в свою очередь занимаются отрисовкой UI. Старшие компоненты используют контейнеры
    как часть их реализации. Вы можете думать о старших компонентах как о параметризованных
    определениях компонентов-контейнеров.</wg:p>

  <br/>
  <h2>3.13.3	Соглашение: передавайте несвязанные с контейнером свойства в упакованный компонент</h2>

  <wg:p>Старшие компоненты добавляют новую функциональность в целевой компонент. Они не должны
    радикально изменять свой протокол взаимодействия с оригинальными компонентами. Ожидается,
    что компонент, возвращенный из старшего компонента, имеет аналогичный интерфейс с исходным компонентом.</wg:p>

  <wg:p>Старшие компоненты должны передавать свойства в исходный компонент, если они никак не связаны
    с его основной работой. Большинство старших компонентов содержат метод отрисовки, который выглядит примерно так:</wg:p>

  <ce:code-example-8/>

  <wg:p>Это соглашение помогает обеспечить максимально гибкое и многоразовое
    использование старших компонентов. </wg:p>

  <br/>
  <h2>3.13.4	Соглашение: максимальная компонуемость</h2>

  <wg:p>Не все старшие компоненты выглядят одинаково. Иногда они принимают только один
    аргумент - завернутый компонент:</wg:p>

  <ce:code-example-9/>

  <wg:p>Обычно старшие компоненты принимают дополнительные аргументы. В этом
    примере объект конфигурации используется для указания зависимостей данных компонента:</wg:p>

  <ce:code-example-10/>

  <wg:p>Наиболее распространенная запись старшего компонента выглядит следующим образом:</wg:p>

  <ce:code-example-11/>

  <wg:p>Если вы разобьете её, легче понять, что происходит.</wg:p>

  <ce:code-example-12/>

  <wg:p>Другими словами, connect - это функция более высокого порядка,
    которая возвращает компонент более высокого порядка!</wg:p>

  <wg:p>Такая форма записи может показаться излишне запутанной или ненужной, но
    она имеет полезное свойство. Старшие компоненты с одним аргументом, такие
    как возвращаются функцией <code>connect</code>, имеют сигнатуру <code>Component => Component</code>.
    Функции, тип вывода которых совпадает с типом ввода, очень легко скомбинировать вместе.</wg:p>

  <ce:code-example-13/>

  <wg:p>(Эта же оссобенность также позволяет использовать <code>connect</code> и другие старшие компоненты
    приведенного выше вида как декораторы, являющимися экспериментальным предложение JavaScript.)</wg:p>

  <wg:p>Функция-утилита <code>compose</code> предоставляется многими сторонними библиотеками,
    включая <b>lodash</b> (как <wg:link href="https://lodash.com/docs/#flowRight">lodash.flowRight</wg:link>),
    <wg:link href="http://redux.js.org/docs/api/compose.html">Redux</wg:link> и
    <wg:link href="http://ramdajs.com/docs/#compose">Ramda</wg:link>.</wg:p>

  <br/>
  <a name="3.13.5"></a>
  <h2>3.13.5 Соглашение: оборачивайте отображаемое имя для простоты отладки</h2>

  <wg:p>Компоненты-контейнеры, созданные старшими компонентами, отображаются в инструментах
    разработчика React, как и любой другой компонент. Чтобы облегчить отладку, выберите
    отображаемое имя, которое сообщает, что это результат старшего компонента.</wg:p>

  <wg:p>Наиболее распространенным методом является оборачивание отображаемого
    имени упокованного компонента. Поэтому, если ваш компонент более высокого
    порядка называется <code>addSubscription</code>, а отображаемое имя обернутого
    компонента - <code>UserList</code>, используйте имя для отображения
    <code>AddSubscription</code> (<code>UserList</code>):</wg:p>

  <ce:code-example-14/>

  <br/>
  <h2>3.13.6	Предостережения</h2>

  <wg:p>Старшие компоненты имеют несколько предостережений, которые не сразу очевидны, если вы
    новичок в React.</wg:p>

  <br/>
  <h3>3.13.6.1	Не используйте старшие компоненты внутри метода “render()”</h3>

  <wg:p>Алгоритм сравнения React (называемый согласованием) использует идентификатор
    компонента, чтобы определить, следует ли обновлять существующее поддерево или удалить
    его и монтировать новое. Если компонент, возвращаемый из <code>render</code>, идентичен (<code>===</code>)
    компоненту из предыдущего вызова <code>render</code>, React рекурсивно обновляет поддерево, сравнивая
    его с новым. Если они не равны, предыдущее поддерево полностью демонтируется.</wg:p>

  <wg:p>Обычно вам не нужно об этом думать. Но это имеет значение для старших компонентов,
    потому что вы не можете их применять к компоненту внутри его метода <code>render</code>:</wg:p>

  <ce:code-example-15/>

  <wg:p>Проблема здесь заключается не только в производительности - перемонтаж компонента
    приводит к потере состояния этого компонента и всех его потомков.</wg:p>

  <wg:p>Вместо этого применяйте старшие компоненты вне определения исходного компонента,
    чтобы результирующий компонент был создан только один раз. Тогда его идентичность
    будет согласованной между отрисовками (вызовами <code>render</code>) компонента. Обычно – это
    именно то, что вам нужно.</wg:p>

  <wg:p>В тех редких случаях, когда вам нужно динамически применять старшие компоненты, вы также можете
    делать это внутри жизненного цикла исходного компонента или его конструктора.</wg:p>

  <br/>
  <h3>3.13.6.2	Статические методы должны быть скопированы</h3>

  <wg:p>Иногда полезно определить статический метод для компонента React. Например, контейнеры Relay предоставляют
    статический метод <code>getFragment</code> для облегчения композиции фрагментов GraphQL.</wg:p>

  <wg:p>Однако, когда вы применяете старший компонент, исходный компонент упаковывается в компонент-контейнер.
    Это означает, что новый компонент не имеет каких-либо статических методов исходного компонента.</wg:p>

  <ce:code-example-16/>

  <wg:p>Чтобы решить эту проблему, вы можете скопировать методы в контейнер, прежде чем возвращать его:</wg:p>

  <ce:code-example-17/>

  <wg:p>Однако для этого требуется, чтобы вы точно знали, какие методы необходимо скопировать.
    Вы можете использовать <wg:link href="https://github.com/mridgway/hoist-non-react-statics">hoist-non-react-statics</wg:link>,
    для автоматического копирования всех статических методов, не связанных с React:</wg:p>

  <ce:code-example-18/>

  <wg:p>Другим возможным решением является экспорт статического метода отдельно от самого компонента.</wg:p>

  <ce:code-example-19/>

  <br/>
  <h3>3.13.6.3	Ссылки не передаются</h3>

  <wg:p>Не смотря на то, что соглашением для компонентов более высокого порядка является
    передача всех свойств через упакованный компонент вниз по дереву иерархии, невозможно
    передать <code>ref</code>. Это происходит потому, что фактически -  <code>ref</code> не является свойством как <code>key</code>,
    он обрабатывается React-от специальным образом. Если вы добавите <code>ref</code> в элемент,
    компонент которого является результатом старшего компонента, <code>ref</code> будет ссылаться
    на экземпляр внешнего компонента-контейнера, а не на упакованный компонент.</wg:p>

  <wg:p>Если вы столкнулись с этой проблемой, идеальным решением является анализ того,
    как вообще избежать использования <code>ref</code>. Иногда пользователи, которые являются новичками
    в парадигме React, полагаются на ссылки <code>ref</code> в ситуациях, когда свойства
    <code>props</code> будут работать лучше.</wg:p>

  <wg:p>Тем не менее, бывают случаи, когда <code>refs</code> являются необходимым аварийным
    выходом – иначе React бы их не поддерживал. Примером может являться фокусировка
    поля ввода, где вы можете потребовать обязательный контроль над компонентом.
    В этом случае одним из решений является передача обратного вызова <code>ref</code> в качестве
    обычного свойства, давая ему другое имя:</wg:p>

  <ce:code-example-20/>

  <wg:p>Это не идеальное решение. Разработчики рекомендуют, чтобы ссылки <code>ref</code>
    оставались заботой сторонних библиотек, а не требовали, чтобы вы вручную их
    обрабатывали. На данный момент ведется исследование путей решения этой проблемы,
    так что использование старших компонентов под наблюдением не находится.</wg:p>
</lt:layout>

<c:url var="prevPageUrl" value="web-components"/>
<c:url var="nextPageUrl" value="integrating-with-other-libraries"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>