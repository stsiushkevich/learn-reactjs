<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/integrating-with-other-libraries" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="granularDomUpdatesUrl" value="/resources/imges/pages/basics/render-elements/granular-dom-updates.gif"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page hello-world-example-page">
  <h1>3.17	Интеграция со сторонними библиотеками</h1>

  <wg:p>React может использоваться в любом веб-приложении. Он может быть встроен в
    другие приложения и, с некоторой осторожностью, другие приложения могут быть встроены
    в React. В этом этой главе будут рассмотрены некоторые из наиболее распространенных
    случаев использования, сосредотачивая основное внимание на интеграции с
    <wg:link href="https://jquery.com/">jQuery</wg:link>,
    но те же идеи могут быть применены для интеграции компонентов с любым существующим кодом.</wg:p>

  <br/>
  <h2>3.17.1	Интеграция с плагинами манипуляции DOM</h2>

  <wg:p>React не знает об изменениях, внесенных в DOM вне контекста React.
    Он определяет обновления, основанные на собственном внутреннем представлении,
    и если одни и те же узлы DOM управляются другой библиотекой, React запутывается
    и не имеет возможности восстановления.</wg:p>

  <wg:p>Это не означает, что невозможно или чрезвычайно сложно совместить React с другими
    способами воздействия на DOM, вам просто нужно понимать, что каждый из них делает.</wg:p>

  <wg:p>Самый простой способ избежать конфликтов - предотвратить обновление компонента
    React. Вы можете сделать это, предоставив элементы, для которых у React нет никаких
    причин их обновлять, например, пустой <code>&lt;div /&gt;</code>.</wg:p>

  <br/>
  <h2>3.17.1.1	Как подойти к проблеме</h2>

  <wg:p>Чтобы это продемонстрировать, давайте построим обёртку для известного плагина jQuery.</wg:p>

  <wg:p>Мы добавим атрибут <code>ref</code> к корневому элементу DOM. Внутри <code>componentDidMount</code> мы получим
    на него ссылку, чтобы можно было передать его в плагин jQuery.</wg:p>

  <wg:p>Чтобы предотвратить взаимодействие React с DOM после монтирования, мы вернем пустой
    тег <code>&lt;div /&gt;</code> из метода <code>render()</code>. Элемент <code>&lt;div /&gt;</code> не имеет свойств или дочерних элементов,
    поэтому у React нет причин обновлять его, оставляя плагину jQuery свободу для
    управления этой частью DOM:</wg:p>

  <ce:code-example-1/>

  <wg:p>Обратите внимание, что мы определили методы жизненного цикла <code>componentDidMount</code> и
    <code>componentWillUnmount</code>. Многие плагины jQuery присоединяют слушателей событий к
    DOM, поэтому важно удалить их в <code>componentWillUnmount</code>. Если плагин не
    предоставляет метод очистки, вам, вероятно, придется предоставить свой собственный,
    чтобы удалить слушатели событий, зарегистрированных плагином, предотвращая тем самым утечку памяти.</wg:p>

  <br/>
  <h2>3.17.1.2	Интеграция с JQuery UI Dialog плагином</h2>

  <wg:p>Для более конкретного примера, давайте напишем минимальную оболочку для плагина
    <wg:link href="http://api.jqueryui.com/dialog/">JQuery UI Dialog</wg:link>.</wg:p>

  <lt:layout cssClass="alert alert-warning">
    <b>Внимание!</b> Просто потому, что это возможно, это совсем не означает, что такой
    подход - лучший для приложений React. Рекомендуется использовать именно компоненты
    React насколько это возможно. React-компоненты более просты для повторного использования
    в приложениях и обеспечивают больший контроль над своим поведением и внешним видом.
  </lt:layout>

  <wg:p>Во-первых, давайте посмотрим, что <code>Dialog</code> делает с DOM.</wg:p>

  <wg:p>Если вы вызываете <code>Dialog</code> на узле DOM <code>&lt;div&gt;</code>, он
    автоматически внесет следующие изменения</wg:p>

  <ce:code-example-2/>

  <wg:p>Предположим, что это API, к которому мы стремимся с помощью
    нашего React-компонента-оболочки <code>&lt;Dialog&gt;</code>:</wg:p>

  <ce:code-example-3/>

  <wg:p>Во-первых, мы создадим компонент с методом <code>render()</code>, где
    будем возвращать <code>&lt;div&gt;</code>:</wg:p>

  <ce:code-example-4/>

  <wg:p>Важно знать, что если вы измените DOM вне потока React, вы должны убедиться,
    что у React нет оснований касаться этих узлов DOM.</wg:p>

  <wg:p>Далее мы реализуем метод жизненного цикла. Нам нужно инициализировать <code>Dialog</code>
    с помощью ссылки <code>ref</code> на узел <code>&lt;div&gt;</code> в <code>componentDidMount</code>:</wg:p>

  <ce:code-example-5 codePenUrl="https://codepen.io/stzidane/pen/EXWJOL"/>

  <wg:p>Обратите внимание на одну очень важную деталь: как мы вызываем диалог из приложения.</wg:p>

  <ce:code-example-6/>

  <wg:p>Мы либо отрисовываем его, либо возвращаем <code>null</code>. Это сделано для того, чтобы диалог
    при открытии и закрытии монтировался и демонтировался каждый раз. Это обеспечит вызов
    методов жизненного цикла компонента диалога, в которых происходит установка и уничтожение
    плагина. Если бы мы показывали диалог таким образом:</wg:p>

  <ce:code-example-7/>

  <wg:p>То его методы жизненного цикла сработали бы лишь один раз при первой отрисовке. А далее
    вызывался бы только его метод <code>render()</code>, так как диалог не монтируется и не демонтируется.</wg:p>

  <wg:p>Также обратите внимание, что React не присваивает какое-то особенное значение полю <code>this.element</code>.
    Оно работает только потому, что мы ранее назначили это поле в атрибуте
    <code>ref</code> в методе <code>render ()</code>:</wg:p>

  <ce:code-example-8/>

  <wg:p>Данный компонент пока не может демонтироваться. Если вы щелкните на кнопке
    «закрыть», то диалог больше не откроется. Это происходит потому, что мы не демонтируем компонент.
    Чтобы это исправить, добавим в компонент диалога метод жизненного цикла <code>componentWillUnmount</code>,
    в котором будем уничтожать диалог:</wg:p>

  <ce:code-example-9/>

  <wg:p>Но чтобы данный метод вызвался, нам необходимо демонтировать наш диалог. Для этого нам понадобится
    атрибут <code>onClose</code> для диалога, которому мы присвоим метод-коллбэк, выставляющий
    <code>isDialogShowed</code> в <code>false</code>:</wg:p>

  <ce:code-example-10/>

  <wg:p>У самого компонента диалога будем использовать коллбэк <code>onClose</code>
    в <code>componentDidMount</code>:</wg:p>

  <ce:code-example-11 codePenUrl="https://codepen.io/stzidane/pen/MopMGW"/>

  <br/>
  <h2>3.17.2	Интеграция с другими библиотеками</h2>

  <wg:p>React может быть встроен в другие приложения благодаря гибкости <code>ReactDOM.render()</code>.</wg:p>

  <wg:p>Хотя React обычно используется при запуске для загрузки единственного корневого React
    компонента в DOM, <code>ReactDOM.render()</code> может быть вызван множество раз для независимых частей
    UI, которые могут быть маленькими как одиночные кнопки, так и большими, как целое приложение .</wg:p>

  <wg:p>Фактически, именно так React используется в Facebook. Это позволяет разработчикам Facebook
    писать приложения на React по частям и комбинировать их с уже существующими, сгенерированными
    сервером шаблонами и другим клиентским кодом.</wg:p>

  <br/>
  <h3>3.17.2.1	Замена отрисовки, основанной на строках, на React</h3>

  <wg:p>Общим паттерном в старых веб-приложениях является описание фрагментов DOM в
    виде строки и вставка их в DOM, например: <code>$element.html(htmlString)</code>. Эти точки в
    кодовой базе идеально подходят для внедрения React. Просто перепишите строковое
    представление как компонент React.</wg:p>

  <wg:p>Итак, следующая реализация jQuery ...</wg:p>

  <ce:code-example-12/>

  <wg:p>... может быть переписана с использованием компонента React:</wg:p>

  <ce:code-example-13/>

  <wg:p>Теперь вы можете начать перемещать больше логики в компонент и применять наиболее
    распространенные практики React. Например, в компонентах лучше не полагаться на
    идентификаторы, потому что один и тот же компонент может отображаться несколько раз.</wg:p>

  <wg:p>Вместо этого мы будем использовать систему событий React и зарегистрируем
    обработчик кликов непосредственно в элементе React <code>&lt;button&gt;</code>:</wg:p>

  <ce:code-example-14/>

  <wg:p>Вы можете иметь столько изолированных компонентов, сколько захотите, и
    использовать <code>ReactDOM.render()</code> для рендеринга их в разные контейнеры DOM.
    Постепенно при преобразовании всё большего количества вашего приложения в
    React вы сможете объединить их в более крупные компоненты и переместить
    некоторые из <code>ReactDOM.render()</code> вызовов выше по иерархии.</wg:p>
</lt:layout>

<c:url var="prevPageUrl" value="forwarding-refs"/>
<c:url var="nextPageUrl" value="/reference/topics"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>