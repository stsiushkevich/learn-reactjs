<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/context" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="granularDomUpdatesUrl" value="/resources/imges/pages/basics/render-elements/granular-dom-updates.gif"/>
<c:url var="codemodeUrl" value="https://reactjs.org/blog/2017/04/07/react-v15.5.0.html#migrating-from-react.proptypes"/>
<c:url var="newReleaseUrl" value="https://github.com/reactjs/rfcs/blob/master/text/0002-new-version-of-context.md"/>
<c:url var="legacyAPIUrl" value="https://reactjs.org/docs/legacy-context.html"/>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page hello-world-example-page">
  <h1>3.9 Контекст</h1>

  <wg:p>
    Контекст обеспечивает способ передачи данных через дерево компонентов
    без необходимости передавать свойства вручную на каждом уровне.
  </wg:p>

  <wg:p>
    В типичном приложении React данные передаются сверху вниз (от родителя к потомку) через
    свойства <code>props</code>. Однако это может оказаться громоздким для определенных типов свойств
    (тема UI; предпочтения, связнные с локалью), которые требуются для многих
    компонентов в приложении. Контекст предоставляет способ совместного использования таких
    значений между компонентами без необходимости явно передавать свойство через каждый уровень дерева.
  </wg:p>

  <wg:p>
    <ul>
      <li><wg:link href="#391">3.9.1 Когда следует использовать контекст?</wg:link></li>
      <li><wg:link href="#392">3.9.2 API.</wg:link>
        <ul>
          <li><wg:link href="#3921">3.9.2.1 React.createContext.</wg:link></li>
          <li><wg:link href="#3922">3.9.2.2 Provider.</wg:link></li>
          <li><wg:link href="#3923">3.9.2.3 Consumer.</wg:link></li>
        </ul>
      </li>
      <li><wg:link href="#393">3.9.3 Примеры.</wg:link>
        <ul>
          <li><wg:link href="#3931">3.9.3.1 Динамический контекст.</wg:link></li>
          <li><wg:link href="#3932">3.9.3.2 Использование контекста из вложенного компонента.</wg:link></li>
          <li><wg:link href="#3933">3.9.3.3 Потребление множества контекстов.</wg:link></li>
          <li><wg:link href="#3934">3.9.3.4 Доступ к контексту в методах жизненного цикла.</wg:link></li>
          <li><wg:link href="#3935">3.9.3.5 Потребление контекста старшим компонентом (HOC-ом).</wg:link></li>
          <li><wg:link href="#3936">3.9.3.6 Передача ссылок ref в потребители контекста.</wg:link></li>
        </ul>
      </li>
      <li><wg:link href="#394">3.9.4 Предостережения.</wg:link></li>
      <li><wg:link href="#395">3.9.5 Устаревший API.</wg:link></li>
    </ul>
  </wg:p>

  <a name="391"></a>
  <br/>
  <h2>3.9.1 Когда следует использовать контекст?</h2>

  <wg:p>
    Контекст разработан для совместного использования данных, которые можно
    рассматривать «глобальными» для дерева React-компонентов, например таких как
    текущий аутентифицированный пользователь, тема или предпочтительный язык. В
    приведенном ниже коде мы вручную передаем свойство «theme», чтобы стилизовать компонент <code>Button</code>:
  </wg:p>

  <ce:code-example-1/>

  <wg:p>Используя контекст, мы можем избежать передачи свойств через промежуточные элементы:</wg:p>

  <ce:code-example-2/>

  <app:alert title="Внимание!" type="warning">
    Не используйте контекст, чтобы избежать передачи свойств на несколько уровней ниже.
    Реальная необходимость возникает в случаях, когда одни и те же данные должны быть
    доступны во многих компонентах на разных уровнях.
  </app:alert>

  <a name="392"></a>
  <br/>
  <h2>3.9.2 API</h2>

  <a name="3921"></a>
  <br/>
  <h3>3.9.2.1 React.createContext.</h3>

  <ce:code-example-3/>

  <wg:p>
    Создает пару <b>потребитель и поставщик(провайдер)</b>: <code>{Provider, Consumer}</code>. Когда
    React будет отрисовывать потребителя контекста <code>Consumer</code>,
    он считает текущее значение контекста из ближайшего соответствующего поставщика <code>Provider</code> выше в дереве иерархии.
  </wg:p>

  <wg:p>
    Аргумент <code>defaultValue</code> используется при отрисовке потребителя контекста, не имеющего соответствующего поставщика
    выше него в дереве. Это может быть полезно для тестирования компонентов изолированно, без их обертывания.
  </wg:p>

  <a name="3922"></a>
  <br/>
  <h3>3.9.2.2 Provider.</h3>

  <ce:code-example-4/>

  <wg:p>
    Компонент React, который позволяет потребителям подписываться на изменения контекста.
  </wg:p>

  <wg:p>
    Принимает свойство <code>value</code>, которое должно быть передано потребителям, которые являются
    потомками данного провайдера. Один провайдер может быть связан со многими потребителями. Провайдеры
    могут быть вложенными, чтобы переопределять значения глубже в дереве.
  </wg:p>

  <a name="3923"></a>
  <br/>
  <h3>3.9.2.3 Consumer.</h3>

  <ce:code-example-5/>

  <wg:p>Компонент React, который подписывается на изменения контекста.</wg:p>

  <wg:p>
    Требует функцию в качестве дочернего элемента. Функция получает текущее значение
    контекста и возвращает узел React. Аргумент <code>value</code>, переданный функции, будет равен
    свойству <code>value</code> ближайшего поставщика для этого контекста выше в дереве. Если для данного
    контекста нет провайдера, аргумент <code>value</code> будет равен значению <code>defaultValue</code>,
    которое было передано в <code>createContext()</code>.
  </wg:p>

  <wg:p>
    Все потребители перерисовываются всякий раз при изменении значения поставщика.
    Изменения определяются путем сравнения старых и новых значений с использованием
    того же алгоритма, что и в <code>Object.is</code>. (Это может вызвать некоторые проблемы при
    передаче объектов в качестве <code>value</code>: см. раздел <wg:link href="#ceveats">Предостережения</wg:link>.)
  </wg:p>

  <a name="393"></a>
  <br/>
  <h2>3.9.3 Примеры.</h2>

  <a name="3931"></a>
  <br/>
  <h3>3.9.3.1 Динамический контекст</h3>

  <wg:p>Более сложный пример с динамическими значениями для темы:</wg:p>

  <wg:p><b>theme-context.js</b></wg:p>

  <ce:code-example-6/>

  <wg:p><b>themed-button.js</b></wg:p>

  <ce:code-example-7/>

  <wg:p><b>app.js</b></wg:p>

  <ce:code-example-8/>

  <a name="3932"></a>
  <br/>
  <h3>3.9.3.2 Обновление контекста из вложенного компонента</h3>

  <wg:p>
    Часто необходимо обновить контекст из компонента, который глубоко вложен
    в дерево компонентов. В этом случае вы можете передать функцию через контекст,
    чтобы позволить потребителям обновлять контекст:
  </wg:p>
  
  <wg:p><b>theme-context.js</b></wg:p>
  
  <ce:code-example-9/>
  
  <wg:p><b>theme-toggler-button.js</b></wg:p>
  
  <ce:code-example-10/>
  
  <wg:p><b>app.js</b></wg:p>
  
  <ce:code-example-11/>

  <a name="3933"></a>
  <br/>
  <h3>3.9.3.3 Потребление множества контекстов</h3>
  
  <wg:p>
    Чтобы поддерживать перерисовку контекста быстрой, React должен
    сделать каждого потребителя контекста отдельным узлом в дереве.
  </wg:p>
  
  <ce:code-example-12/>
  
  <wg:p>
    Если два и более значения контекста часто используются вместе, вы можете
    рассмотреть возможность создания вашего собственного <code>render prop</code> компонента,
    который будет их предоставлять.
  </wg:p>

  <a name="3934"></a>
  <br/>
  <h3>3.9.3.4 Доступ к контексту в методах жизненного цикла</h3>
  
  <wg:p>
    Доступ к значениям из контекста в методах жизненного цикла является довольно
    частой ситуацией. Вместо добавления контекста в каждый метод жизненного цикла
    вам просто нужно передать его как свойство, а затем работать с ним так же,
    как и с обычным свойством.
  </wg:p>
  
  <ce:code-example-13/>

  <a name="3935"></a>
  <br/>
  <h3>3.9.3.5 Потребление контекста старшим компонентом (HOC-ом)</h3>
  
  <wg:p>
    Некоторые типы контекстов могут потребляться многими компонентами (например, тема или локализация).
    Может быть утомительно явно обертывать каждую зависимость с помощью
    элемента <code>&lt;Context.Consumer&gt;</code>. Старший компонент может помочь избежать этого.
  </wg:p>
  
  <wg:p>
    Например, компонент кнопки может потреблять контекст темы следующим образом:
  </wg:p>
  
  <ce:code-example-14/>
  
  <wg:p>
    Для нескольких компонентов это выглядит хорошо, но что, если бы мы
    захотели использовать контекст темы во множестве мест?
  </wg:p>
  
  <wg:p>Мы могли бы создать старший компонент с <code>withTheme</code>:</wg:p>
  
  <ce:code-example-15/>
  
  <wg:p>
    Теперь любой компонент, который зависит от контекста темы, может легко
    подписаться на него с помощью созданной нами функции <code>withTheme</code>:
  </wg:p>
  
  <ce:code-example-16/>

  <a name="3936"></a>
  <br/>
  <h3>3.9.3.6 Передача ссылок ref в потребители контекста</h3>
  
  <wg:p>
    Одна из проблем с <code>render prop</code> API-интерфейсом заключается в том,
    что ссылки <code>ref</code> не передается автоматически обернутым элементам. Чтобы
    обойти это, используйте <code>React.forwardRef</code>:
  </wg:p>
  
  <wg:p><b>fancy-button.js</b></wg:p>
  
  <ce:code-example-17/>
  
  <wg:p><b>app.js</b></wg:p>
  
  <ce:code-example-18/>

  <a name="394"></a>
  <br/>
  <h2>3.9.4 Предостережения</h2>
  
  <wg:p>
    Поскольку контекст использует ссылочную идентификацию, чтобы определить,
    когда нужно проводить перерисовку, существуют некоторые "подводные камни",
    которые могут вызвать непреднамеренные отрисовки в потребителях, когда перерисовывается
    родитель поставщика. Например, приведенный ниже код будет повторно отрисовывать всех
    потребителей каждый раз, когда перерисовывается поставщик, потому что для <code>value</code>
    всегда создается новый объект:
  </wg:p>

  <ce:code-example-19/>

  <wg:p>
    Чтобы обойти это, поднимите значение в состояние родителя:
  </wg:p>

  <ce:code-example-20/>

  <a name="395"></a>
  <br/>
  <h3>3.9.5 Устаревший API</h3>

  <app:alert type="warning" title="Внимание!">
    Ранее React предоставлял экспериментальный API контекста. Устаревший API будет поддерживаться
    во всех релизах <b>16.x</b>, но приложения, использующие его, должны мигрировать на новую версию. Он будет
    удален в будущей major-версии React. Ознакомиться с устаревшим API контекста вы сможете <wg:link href="${legacyAPIUrl}">здесь.</wg:link>
  </app:alert>

</lt:layout>

<c:url var="prevPageUrl" value="reconciliation"/>
<c:url var="nextPageUrl" value="portals"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>