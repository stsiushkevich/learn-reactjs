<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/hooks/introduction" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<c:url var="glansSectionUrl" value="glans"/>

<a name="pageStart"></a>
<div class="black-line"></div>
<div class="page create-new-react-app">
    <h1>3.12.1 Представляем хуки</h1>
    
    <br/>
    
    <p class="introduction">
        Хуки - это новая функция, которая позволяет вам использовать состояние и другие
        функции React без написания класса. В настоящее время они доступны в <b>React v16.8.0-alpha.0</b>.
    </p>
    
    <ce:code-example-1/>
    
    <p>
        Новая функция <code>useState</code> является <b>«хуком»</b> (в оригинале <b>hook</b> - крюк).
        О ней мы поговорим позднее, а данный пример - просто тизер. Не переживайте,
        если пока не понимаете приведенный код!
    </p>
    
    <p>
        Вы можете начать изучать хуки <b><a href="${glansSectionUrl}">в следующем разделе</a></b>. А в этом разделе мы дадим объяснение того,
        почему мы добавляем хуки в React и как они могут помочь вам в создании отличных приложений.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.1.1 Видео</h2>
    
    <p>
        На React конференции 2018 Софи Альперт и Дэн Абрамов представили хуки, а затем
        Райан Флоренс продемонстрировал, как выполнить рефакторинг приложения для их
        использования. Смотрите видео:
    </p>
    
    <wg:video id="hooks-introduction-1"/>
    
    <a name="no-breaking-changes"></a>
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.1.2 Критические изменения отсутствуют</h2>
    <br/>
    
    <p>Прежде чем продолжить, обратите внимание, что хуки:</p>
    
    <ul>
        <li>
            <p>
                <b>Исключительно по желанию</b>. Вы можете попробовать хуки в нескольких компонентах,
                не переписывая существующий код. Но вы не обязаны изучать или использовать хуки прямо
                сейчас.
            </p>
        </li>
        <li>
            <p>
                <b>100% обратно-совместимые</b>. Хуки не содержат каких-либо критических изменений.
            </p>
        </li>
        <li>
            <p>
                <b>Доступны сейчас</b>. Хуки в настоящее время находятся в альфа-релизе, и мы надеемся
                включить их в React 16.x после получения отзывов сообщества.
            </p>
        </li>
    </ul>
    
    <p>
        <b>Нет планов по удалению классов из React</b>. Вы можете прочитать больше о стратегии
        постепенного принятия хуков в нижней части этого раздела.
    </p>
    
    <p>
        <b>Хуки не исключают ваши знания концепций React</b>. Вместо этого, хуки предоставляют более
        прямой API для уже знакомых вам понятий React: свойства, состояние, контекст, ссылки <code>ref</code> и жизненный цикл.
        Как мы покажем позже, хуки также предлагают новый мощный способ их комбинирования.
    </p>
    
    <p>
        <b>Если вы просто хотите начать изучать хуки</b>, не стесняйтесь перейти <b><a href="${glansSectionUrl}">на следующий раздел</a></b>
        прямо сейчас! Вы также можете продолжать читать этот раздел, чтобы узнать больше о том, почему мы добавляем хуки
        и как мы собираемся начать их использовать, не переписывая наши приложения.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.1.3 Мотивы</h2>
    <br/>
    
    <p>
        Хуки решают широкий спектр, казалось бы, не связанных между собой проблем в React,
        с которыми мы сталкивались в течение пяти лет написания и обслуживания десятков тысяч
        компонентов. Если вы изучаете React, используете его ежедневно или даже предпочитаете
        другую библиотеку с похожей компонентной моделью, вы можете распознать некоторые из таких проблем.
    </p>
    
    <br/>
    <h3>3.12.1.3.1 Тяжело повторно использовать логику состояний между компонентами</h3>
    <br/>
    
    <c:url var="renderPropUrl" value="/core/render-prop"/>
    <c:url var="higherOrderComponentsUrl" value="core/higher-order-components"/>
    
    <p>
        React не предлагает способ «прикрепить» повторно используемое поведение к компоненту.
        Если вы какое-то время работали с React, вы можете быть
        знакомы с такими паттернами, как <b><a href="${renderPropUrl}">свойство <code>render</code></a></b> и
        <b><a href="${higherOrderComponentsUrl}">компоненты более высокого порядка</a></b>,
        которые пытаются решить эту проблему. Но для своего использования данные паттерны требуют,
        чтобы вы реструктурировали свои компоненты, что может сделать код сложным и громоздким.
        Если вы посмотрите на типичное приложение React в React DevTools, вы, скорее всего, увидите
        «адское обёртывание» компонентов, находящимися под слоями провайдеров, потребителей, компонентов
        более высокого порядка, свойств <code>render</code> и других абстракций. Хотя мы и можем отфильтровать их в DevTools,
        всё же это указывает на более глубокую скрытую проблему: React нужен лучший примитив для
        обмена логикой состояний.
    </p>
    
    <p>
        С помощью хуков вы можете извлекать логику работы с состоянием из компонента, так что
        она может быть протестирована независимо и использована повторно. <b>Также хуки позволяют
        вам повторно использовать логику работы с состоянием без изменения вашей иерархии компонентов</b>.
        Это дает возможность совместного использования хуков многими компонентами или сообществом.
    </p>
    
    <c:url var="customHookUrl" value="/custom-hook"/>
    
    <p>
        Мы обсудим это подробнее в разделе «<b><a href="${customHookUrl}">Создание собственных хуков</a></b>».
    </p>
    
    <br/>
    <h3>3.12.1.3.2 Сложные компоненты становятся тяжелыми для понимания</h3>
    <br/>
    
    <p>
        Нам часто приходилось поддерживать компоненты, которые вначале были простыми,
        но переросли в неуправляемый беспорядок, состоящий из логики состояния и побочных
        эффектов. Каждый метод жизненного цикла часто содержит смесь несвязанной логики.
        Например, компоненты могут выполнять некоторую выборку данных в <code>componentDidMount</code> и
        <code>componentDidUpdate</code>. Однако тот же метод <code>componentDidMount</code> может также содержать
        некоторую логику, которая устанавливает слушатели событий, а очистка выполняется в
        <code>componentWillUnmount</code>. Таким образом совершенно не связанный код в конечном итоге
        объединяется в одом методе. В таком коде очень легко вводить ошибки и несоответствия.
    </p>
    
    <p>
        Во многих случаях невозможно разбить такие компоненты на меньшие, так как
        логика работы с состоянием повсюду. Также, их сложно тестировать. Это одна из
        причин, по которой многие люди предпочитают комбинировать React со сторонней
        библиотекой управления состоянием. Однако это часто вводит слишком много абстракции,
        требует постоянного перехода между разными файлами и усложняет повторное использование компонентов.
    </p>
    
    <p>
        Чтобы решить эту проблему, <b>хуки позволяют разделить один компонент на более мелкие
        функции в зависимости от того, какие части связаны (например, настройка подписки или выборка данных)</b>,
        вместо топорного разделения в методах жизненного цикла. Вы также можете использовать управление
        локальным состоянием компонента с помощью редьюсера (reducer), чтобы сделать работу состояния более
        предсказуемой.
    </p>
    
    <c:url var="effectHookUrl" value="/effect-hook"/>
    
    <p>
        Мы обсудим это подробнее в разделе «<b><a href="${effectHookUrl}">Создание хука эффекта</a></b>».
    </p>
    
    <br/>
    <h3>3.12.1.3.3 Классы путают как людей, так и машины</h3>
    <br/>
    
    <p>
        В добавок к усложнению повторного использования и организации кода мы обнаружили,
        что классы могут стать серьезным препятствием для изучения React. Вы должны понимать,
        как в JavaScript работает <code>this</code>, что сильно отличается от того, как он работает в большинстве
        языков. Вы должны не забыть привязать обработчики событий. Без нестабильного синтаксического
        сахара код очень громоздкий. Люди могут отлично понимать свойства, состояние и нисходящий поток
        данных, но все еще сражаться с классами. Различие между компонентами-функциями и классами в React и
        тем, когда их использовать, приводит к разногласиям даже между опытными разработчиками React.
    </p>
    
    <c:url var="svelteUrl" value="https://svelte.technology/"/>
    <c:url var="angularUrl" value="https://angular.io/"/>
    <c:url var="glimmerjsUrl" value="https://glimmerjs.com/"/>
    <c:url var="aheadOfTimeCompilationUrl" value="https://en.wikipedia.org/wiki/Ahead-of-time_compilation"/>
    <c:url var="issue7323Url" value="https://github.com/facebook/react/issues/7323"/>
    <c:url var="prepackUrl" value="https://prepack.io/"/>
    
    <p>
        Кроме того, React существует уже около пяти лет, и мы хотим убедиться, что он
        останется актуальным и в течение последующих пяти лет. Как показывают <b><a href="${svelteUrl}">Svelte</a></b>,
	    <b><a href="${angularUrl}">Angular</a></b>, <b><a href="${glimmerjsUrl}">Glimmer</a></b> и другие,
	    <b><a href="${aheadOfTimeCompilationUrl}">предварительная компиляция компонентов</a></b> имеет большой потенциал в
        будущем. Особенно если это не ограничено шаблонами. Недавно мы экспериментировали со
        <b><a href="${issue7323Url}">складыванием</a></b> (фолдингом - folding) компонентов с помощью <b><a href="${prepackUrl}">Prepack</a></b> и получили многообещающие первые результаты.
        Однако мы обнаружили, что компоненты-классы могут стимулировать непреднамеренные шаблоны,
        которые вынуждают эти оптимизации идти по более медленному пути. Классы также представляют
        проблемы для современных инструментов. Например, классы не очень хорошо минимизируются,
        также они делают горячая перезагрузку ненадежной. Мы хотим представить API, который повысит
        вероятность того, что код останется на оптимизируемом пути.
    </p>
    
    <p>
	    Чтобы решить эти проблемы, <b>хуки позволяют вам использовать больше возможностей
	    React без классов</b>. Концептуально компоненты React всегда были ближе к функциям.
	    Хуки охватывают функции, не жертвуя при этом практическим духом React. Они обеспечивают
	    доступ к императивным аварийным люкам и не требуют от вас изучения сложных функциональных
	    или реактивных методов программирования.
    </p>
	
		<c:url var="glanceUrl" value="glance"/>
	
		<app:alert title="Примеры" type="warning">
			<b><a href="${glanceUrl}">Краткий обзор хуков</a></b> - это хорошее место для начала изучения.
		</app:alert>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.1.4 Стратегия постепенного внедрения</h2>
    <br/>
    
    <app:alert title="Внимание!" type="warning">
        <b>Нет планов по удалению классов из React.</b>
    </app:alert>
	
    <p>
        Мы знаем, что React разработчики сосредоточены на поставке продуктов, и у них
        нет времени изучать каждый новый выпускаемый API. Хуки являются очень новой функцией,
        и, возможно, было бы лучше подождать большего числа примеров и учебных пособий, прежде
        чем рассматривать и внедрять их.
    </p>
    
    <c:url var="rfcUrl" value="https://github.com/reactjs/rfcs/pull/68"/>
    
    <p>
        Мы также понимаем, что планка для добавления нового примитива в React
        чрезвычайно высока. Для любознательных читателей мы подготовили <b><a href="${rfcUrl}">подробный RFC</a></b>,
        который углубляется в мотивацию более детально и открывает дополнительную
        перспективу для определенных решений по дизайну кода.
    </p>
    
    <p>
        <b>Важно отметить, что хуки работают бок о бок с существующим кодом,
            поэтому вы можете постепенно их внедрять.</b> Мы делимся нашим экспериментальным API для того,
        чтобы получить самую раннюю обратную связь в сообществе от тех, кто заинтересован в
        формировании будущего React.
    </p>
    
    <c:url var="feedbackUrl" value="https://github.com/facebook/react/issues/new"/>
    
    <p>
        Наконец, нет никакой весомой необходимости переходить на хуки. Мы
        рекомендуем избегать любых «больших переделок», особенно для существующих
        сложных компонентов-классов. Чтобы начать «думать в терминах хуков» необходим
        некоторый "умственный сдвиг". По нашему опыту, лучше всего потренироваться в
        использовании хуков сначала на новых и некритических компонентах, убедившись,
        что все члены вашей команды чувствуют себя с ними комфортно. После того, как вы
        попробуете хуки, отправьте нам <b><a href="${feedbackUrl}">свой отзыв</a></b>,
        неважно, положительный или отрицательный.
    </p>
    
    <p>
        Для хуков мы намерены охватить все существующие варианты использования
        классов, <b>продолжая поддерживать компоненты-классы в обозримом будущем</b>. В
        Facebook у нас есть десятки тысяч компонентов, написанных в виде классов, и
        у нас нет абсолютно никаких планов их переписывать. Вместо этого мы начинаем
        использовать хуки в новом коде бок о бок с ними.
    </p>
    
    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.1.5 Следующие шаги</h2>
    <br/>
    
    <p>
        К концу данного раздела вы должны иметь приблизительное представление о том,
        какие проблемы решают хуки, но многие детали, вероятно, неясны. Не волнуйтесь!
        <b>Теперь давайте перейдем к <b><a href="${glanceUrl}">следующему разделу</a></b>,
            где мы начнем узнавать о хуках на конкретных примерах.</b>
    </p>
    
    <%-- <c:url var="Url" value=""/> --%>
    <%--
		<ul>
			<li>
				<p>
				
				</p>
			</li>
		</ul>
		--%>
    <%-- <app:alert title="Внимание!" type="warning"></app:alert> --%>
    <%-- <code></code> --%>
    <%-- <b></b> --%>
    <%-- <code>&lt; &gt;</code> --%>
    <%-- <b><a href="${}"></a></b> --%>
    <%-- <b><a href="#"></a></b> --%>
    <%-- <a href="#"></a> --%>

</div>

<c:url var="prevPageUrl" value="create-a-new-react-app"/>
<c:url var="nextPageUrl" value="/basics/topics"/>

<app:page-navigate
    pageStartAncor="pageStart"
    prevPageUrl="${prevPageUrl}"
    nextPageUrl="${nextPageUrl}"
/>