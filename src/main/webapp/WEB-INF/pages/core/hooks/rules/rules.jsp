<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/hooks/rules" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>
<%@taglib prefix="ad" tagdir="/WEB-INF/tags/application/advertising" %>

<a name="pageStart"></a>
<div class="black-line"></div>
<div class="page hooks-glance-page">
    <h1>3.12.5 Правила использования хуков</h1>

    <br/>

    <p class="introduction">
        Хуки доступны в версии <b>React 16.8</b>. Они позволяют использовать состояние и другие
        функции React, освобождая от необходимости писать класс.
    </p>

    <br/>

    <c:url var="eslintPluginUrl" value="https://www.npmjs.com/package/eslint-plugin-react-hooks"/>

    <p>
        Хуки являются обычными функциями JavaScript, но при их использовании необходимо следовать
        двум правилам. Мы предоставляем <b><a href="${eslintPluginUrl}">ESLint плагин</a></b>,
        который применяет эти правила автоматически:
    </p>

    <br/>
    <h3>Вызывайте хуки только на верхнем уровне</h3>
    <br/>

    <p>
        <b>Не вызывайте хуки внутри циклов, условий или вложенных функций.</b> Всегда используйте хуки
        только на самом верхнем уровне вашего компонента-функции React. Следуя этому правилу, вы гарантируете,
        что хуки вызываются в одном и том же порядке каждый раз при отрисовке компонента. Это именно то, что
        позволяет React правильно сохранять состояние хуков между несколькими вызовами <code>useState</code> и <code>useEffect</code>.
        (Если вам любопытно, мы подробно поговорим об этом ниже.)
    </p>

    <br/>
    <h3>Вызывайте хуки только из компонентов-функций React</h3>
    <br/>

    <p><b>Не вызывайте хуки из обычных функций JavaScript.</b> Вместо этого вы можете:</p>

    <ul>
        <li>
            <p>
                ✅ Вызывать хуки из компонентов-функций React.
            </p>
        </li>
        <li>
            <p>
                ✅ Вызывать хуки из пользовательских хуков (с ними мы познакомимся в следующем разделе).
            </p>
        </li>
    </ul>

    <p>
        Следуя этому правилу, вы гарантируете, что вся логика состояния компонента
        четко видна из его исходного кода.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.5.1 ESLint плагин</h2>
    <br/>

    <p>
        Мы выпустили ESLint плагин под названием <b><a href="${eslintPluginUrl}">eslint-plugin-react-hooks</a></b>, который применяет
        два эти правила. Чтобы его попробовать, нужно добавить плагин в свой проект:
    </p>

    <ce:code-example-1/>

    <ce:code-example-2/>

    <p>
        В будущем мы намерены добавить этот плагин  в приложение
        «Create React App» (и другие подобные инструменты) по умолчанию.
    </p>

    <p>
        <b>Вы прямо сейчас можете перейти к следующему разделу, который объясняет, как писать
        свои собственные хуки.</b> Здесь же мы объясним причины таких правил.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.5.2 Почему возникли эти правила?</h2>
    <br/>

    <p>
        Как мы узнали ранее, мы можем использовать несколько хуков
        состояния или эффекта в одном компоненте:
    </p>

    <ce:code-example-3/>

    <p>
        Итак, каким образом React понимает, какое состояние какому вызову <code>useState</code> соответствует? Подход состоит
        в том, что <b>React опирается на порядок, в котором вызываются хуки.</b> Наш пример работает, потому что
        порядок вызовов хуков одинаков при каждой отрисовке:
    </p>

    <ce:code-example-4/>

    <p>
        До тех пор, пока порядок вызова хуков одинаков между отрисовками, React
        с каждым из них может связать некоторое локальное состояние. Но что
        произойдет, если мы поместим вызов хука (например, эффект <code>persistForm</code>) в условие?
    </p>

    <ce:code-example-5/>

    <p>
        Во время первой отрисовки условие <code>name !== ''</code> равно <code>true</code>, поэтому мы запускаем этот хук. Однако
        при следующей отрисовке пользователь может очистить форму, сделав условие равным <code>false</code>. В таком случае мы
        пропускаем наш хук во время отрисовки, и порядок вызова хуков становится другим:
    </p>

    <ce:code-example-6/>

    <p>
        React не будет знать, что нужно вернуть для второго вызова хука <code>useState</code>.
        React ожидал, что второй вызов хука в этом компоненте соответствует эффекту <code>persistForm</code>,
        как и во время предыдущей отрисовки, но эффекта больше нет. С этого момента каждый следующий
        вызов хука после пропущенного нами будет сдвинут на один, что приведет к ошибкам.
    </p>

    <p>
        <b>Вот почему хуки должны вызываться на самом верхнем уровне наших компонентов.</b>
        Если же нам нужно запустить эффект по условию, мы можем поместить это условие в наш хук:
    </p>

    <ce:code-example-7/>

    <p>
        <b>Обратите внимание, что вам не нужно беспокоиться об этой проблеме, если вы используете
        предоставленный</b> <b><a href="${eslintPluginUrl}">ESLint плагин</a></b>. Плюс ко всему вы
        теперь знаете, почему хуки работают именно так, и от
        каких проблем вас уберегает данное правило.
    </p>

    <br/>
    <br/>
    <div class="gray-line"></div>
    <h2>3.12.5.3 Следующие шаги</h2>
    <br/>

    <c:url var="customHookUrl" value="custom-hook"/>

    <p>
        Наступил момент, когда мы готовы узнать, как можно написать <b><a href="${customHookUrl}">свои
        собственные хуки</a></b>! Пользовательские хуки позволяют комбинировать хуки, предоставляемые
        React, в свои собственные абстракции и повторно использовать общую логику состояния между
        различными компонентами.
    </p>

    <%-- <c:url var="Url" value=""/> --%>
    <%--
		<ul>
			<li>
				<p>

				</p>
			</li>
		</ul>
		--%>
    <%-- <app:alert title="Внимание!" type="warning"></app:alert> --%>
    <%-- <code></code> --%>
    <%-- <b></b> --%>
    <%-- <code>&lt; &gt;</code> --%>
    <%-- <b><a href="${}"></a></b> --%>
    <%-- <b><a href="#"></a></b> --%>
    <%-- <a href="#"></a> --%>

</div>

<c:url var="prevPageUrl" value="/core/hooks/effect-hook"/>
<c:url var="nextPageUrl" value="/core/hooks/custom-hook"/>

<app:page-navigate
        pageStartAncor="pageStart"
        prevPageUrl="${prevPageUrl}"
        nextPageUrl="${nextPageUrl}"
/>
