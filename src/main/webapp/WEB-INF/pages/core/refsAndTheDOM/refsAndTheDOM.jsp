<%@ page contentType="text/html;charset=UTF-8" language="java" %>

<%@taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<%@taglib prefix="lt" tagdir="/WEB-INF/tags/layout" %>
<%@taglib prefix="wg" tagdir="/WEB-INF/tags/widget" %>
<%@taglib prefix="ce" tagdir="/WEB-INF/tags/application/core/refs-and-the-dom" %>
<%@taglib prefix="app" tagdir="/WEB-INF/tags/application" %>

<a name="pageStart"></a>
<lt:layout cssClass="black-line"/>
<lt:layout cssClass="page hello-world-example-page">
  <h1>3.3 Ссылки ref и DOM</h1>

  <wg:p>В типичном потоке данных React, свойства <code>props</code> – это единственный способ
    взаимодействия родительского компонента с его потомком. Чтобы модифицировать потомка,
    вы перерисовываете его с новыми свойствами. Тем не менее, есть несколько случаев,
    когда вам необходимо модифицировать потомок вне обычного потока данных. Потомок,
    подлежащий модификации, может быть экземпляром React компонента или являться DOM элементом.
    Для обоих этих случаев, React предоставляет «запасной выход».</wg:p>

  <br/>
  <h2>3.3.1 Когда использовать ссылки ref</h2>

  <wg:p>Существует несколько оправданых случаев использования ссылок <code>ref</code>:</wg:p>

  <wg:p>
    <ul>
      <li>Управление фокусом, выделением текста или воспроизведением мультимедиа</li>
      <li>Переключение необходимой анимации</li>
      <li>Интеграция со сторонними DOM библиотеками</li>
    </ul>
  </wg:p>

  <wg:p><b>Избегайте использования ссылок для всего, что может быть реализовано декларативным путем!</b></wg:p>

  <wg:p>К примеру, вместо публичных методов <code>open()</code> и <code>close()</code> на компоненте <code>Dialog</code>,
    передавайте в него свойство <code>isOpen</code>.</wg:p>

  <br/>
  <h2>3.3.2 Не злоупотребляйте ссылками ref</h2>

  <wg:p>По началу вы можете быть склонны использовать ссылки ref для того, чтобы
    «достигнуть результата» в вашем приложении. Если это так, то возьмите немного
    времени и  подумайте более критично о том, кто должен владеть состоянием в иерархии компонентов.
    Часто, становится понятно, что правильное место, где должно находиться состояние,
    это более высокий уровень в иерархии. Смотрите главу «Передача состояния вверх по иерархии» в
    качестве примера.</wg:p>

  <br/>
  <h2>3.3.3 Добавление ссылки ref на DOM элемент</h2>

  <wg:p>React поддерживает специальный атрибут, который вы можете поставить на любой компонент.
    Атрибут <code>ref</code> принимает функцию обратного вызова, которая будет выполнена немедленно после того,
    как компонент был монтирован или демонтирован.</wg:p>

  <wg:p>Когда атрибут <code>ref</code> используется на HTML элементе, функция обратного вызова этого
    атрибута принимает этот элемент как аргумент. К примеру, данный код использует функция
    обратного вызова атрибута <code>ref</code>, чтобы сохранить ссылку на узел DOM:</wg:p>

  <ce:code-example-1/>

  <wg:p>React вызовет коллбэк атрибута <code>ref</code> с DOM элементом как аргумент, когда компонент будет
    монтирован, и с <code>null</code>, когда будет демонтирован.</wg:p>

  <wg:p> Использование коллбэка атрибута <code>ref</code>, который правильным образом установлен
    в классе компонента, является общим паттерном доступа к DOM элементам. Предпочтительным
    способом является установка свойства в коллбэке атрибута <code>ref</code>, как в примере выше.
    Есть еще более короткий способ записать его: <code>ref={input => this.textInput = input}</code>.</wg:p>

  <br/>
  <h2>3.3.4 Добавление ссылки ref на компонент</h2>

  <wg:p>Когда атрибут <code>ref</code> используется на пользовательском компоненте, объявленом как класс,
    коллбэк атрибута <code>ref</code> принимает монтированный экземпляр компонента как аргумент.
    Чтобы это сымитировать, мы обернем <code>MyTextField</code> выше, и сделаем фокус сразу после монтирования:</wg:p>

  <ce:code-example-2/>

  <wg:p>Обратите внимание, что он работает только если <code>MyTextField</code> объявлен как класс:</wg:p>

  <ce:code-example-3/>

  <br/>
  <h2>3.3.5 Ссылки ref и функциональные компоненты</h2>

  <wg:p><b>Нельзя использовать атрибут ref на функциональных компонентах, потому что они не имеют экземпляров:</b></wg:p>

  <ce:code-example-4/>

  <wg:p>Вы должны преобразовать компонент в класс, если хотите ссылаться на него. Точно так же вы делаете,
    когда вам необходимо наделить компонент методами жизненного цикла и состоянием.</wg:p>

  <wg:p>Вы, тем не менее, <b>можете использовать атрибут ref внутри функционального компонента</b>,
    так как вы ссылаетесь на DOM элемент или класс компонента:</wg:p>

  <ce:code-example-5/>

  <br/>
  <h2>3.3.6 Доступ к ссылкам ref из родительских компонентов</h2>

  <wg:p>В редких случаях, вы можете захотеть получать доступ к DOM элементам потомков из родительского
    компонента. Как правило, это не рекомендуется, потому что это разрушает инкапсуляцию компонента.
    Но изредка это может быть полезным для переключения фокуса или определения размера или позиции DOM
    элемента потомка.</wg:p>

  <wg:p>В то время как вы имеете возможность добавлять ссылку на компонент потомка, это не
    является идеальным решением, так как в коллбэке атрибута <code>ref</code> вы можете получить только
    экземпляр компонента, а не DOM узел. Вдобавок, это не будет работать с функциональными компонентами.</wg:p>

  <wg:p>Вместо этого, в таких случаях рекомендуется делать общедоступным специальное свойство в потомке.
    Потомок принимает функциональное свойство с произвольным именем (например, <code>inputRef</code>) и
    добавляет его на DOM узел как атрибут <code>ref</code>. Это позволяет родителю передавать
    коллбэк этого атрибута DOM узлу через компонент потомка.</wg:p>

  <wg:p>Это работает как для классов, так и для функциональных компонентов.</wg:p>

  <ce:code-example-6/>

  <wg:p>В примере выше, <code>ParentComponent</code> передает свой коллбэк итрибута <code>ref</code>
    как свойство <code>inputRef</code> в  <code>ChildComponent</code>. <code>ChildComponent</code> передает эту
    функцию как специальный атрибут <code>ref</code> тегу <code>&lt;input&gt;</code>. В результате
    свойству <code>this.inputElem</code> в компоненте <code>ParentComponent</code> будет присвоен
    DOM узлел соответствующего <code>&lt;input&gt;</code> элемента в компоненте <code>ChildComponent</code>.</wg:p>

  <wg:p>Обратите внимание, что имя свойства <code>inputRef</code> в примере выше не несет никакого
    особого смысла, так как является обычным свойством компонента. Тем не менее,
    использование атрибута <code>ref</code> на самом элементе <code>&lt;input&gt;</code> очень важно, так как это
    говорит React прикрепить ссылку на его DOM узел.</wg:p>

  <wg:p>Это работает даже если <code>ChildComponent</code> является функциональным компонентом.
    В отличии от специального атрибута <code>ref</code>, который может быть указан только для
    DOM элементов и классов  компонентов, не существует ограничений  на обычные
    свойства компонента, такие как <code>inputRef</code>.</wg:p>

  <wg:p>Еще одна польза этого паттерна заключается в том, что он работает на
    несколько компонентов вглубину. К примеру, представим, что компонент <code>Parent</code>
    не нуждается в DOM узле, но компонент, который отрисовывает <code>Parent</code>
    (давайте назавём его <code>Grandparent</code>) нуждается в доступе к этому узлу.
    Тогда мы должны позволить <code>Grandparent</code> указать свойство <code>textFieldRef</code> на <code>Parent</code>, и
    позволить <code>Parent</code> передать его в <code>TextField</code>:</wg:p>

  <ce:code-example-7/>

  <wg:p>Здесь, коллбэк атрибута <code>ref</code> сперва указывается компонентом <code>Grandparent</code>.
    Он передается <code>Parent</code> как обычное свойство с именем <code>textFieldRef</code>, а <code>Parent</code>
    передает его в <code>TextField</code> - тоже как свойство. В итоге, <code>TextField</code> считывает
    свойство <code>textFieldRef</code> и присваивает переданный коллбэк атрибуту <code>ref</code> тега <code>&lt;input&gt;</code>.
    Как результат, поле <code>this.textField</code> в компоненте <code>Grandparent</code> будет установлено в
    DOM узел соответствующего <code>&lt;input&gt;</code> элемента в <code>TextField</code>.</wg:p>

  <wg:p>Учитывая все обстоятельства, мы рекомендуем избегать общедоступности DOM
    узлов насколько это возможно, но иногда это может оказаться полезным аварийным
    выходом. Обратите внимание, что этот подход требует от вас добавления некоторого
    кода в дочерний компонент. Если вы не имеет абсолютно никакого контроля над
    реализацией дочернего компонента, вашей последней возможностью будет
    использование <code>findDOMNode()</code>, но это не рекомендуется.</wg:p>

  <br/>
  <h2>3.3.7 Старый API: Строковые ссылки ref</h2>

  <wg:p>Если вы использовали React ранее, вы могли быть знакомы со старым API,
    где <code>ref</code> атрибут мог быть строкой, вроде “<code>textField</code>”, и DOM узел был доступен
    как <code>this.refs.textInput</code>. Мы рекомендуем избегать этого, потому что строковые
    ссылки имеют некоторые проблемы, являются устаревшими и скорее всего будут
    удалены в следующих релизах. Если же вы до сих пор используете <code>this.refs.textInput</code>,
    чтобы получать доступ к ссылкам, мы рекомендуем вместо этого использовать паттерн
    <b>callback</b>(функции обратного вызова).</wg:p>

  <br/>
  <h2>3.3.8 Предостережения</h2>

  <wg:p>Если коллбэк атрибута <code>ref</code> определен как встроенная функция,
    <b>она будет вызываться дважды во время перерисовок</b>: сперва с <code>null</code>,
    а затем снова с DOM элементом. Это происходит потому, что новый
    экземпляр функции создается во время каждой фазы отрисовки, поэтому
    React необходимо очистить старый <code>ref</code> и установить новый. Вы можете
    эгого избежать, определяя коллбэк как связанный метод в классе, но
    обратите внимание, что в большинстве случаев это не имеет большого значения.</wg:p>
</lt:layout>

<c:url var="prevPageUrl" value="typechecking-with-prop-types"/>
<c:url var="nextPageUrl" value="uncontrolled-components"/>
<app:page-navigate prevPageUrl="${prevPageUrl}"
                   pageStartAncor="pageStart"
                   nextPageUrl="${nextPageUrl}"/>